"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[1722],{68563:function(e,t,n){n.r(t);var s=n(11151),r=n(67294),l=n(17493),a=n(89482),i=n(77884);function o(e){const t=Object.assign({h1:"h1",a:"a",span:"span",p:"p",h2:"h2",h3:"h3",ul:"ul",li:"li",pre:"pre",code:"code",ol:"ol",strong:"strong"},(0,s.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.h1,{id:"server-side-rendering",style:{position:"relative"}},"Server-side rendering",r.createElement(t.a,{href:"#server-side-rendering","aria-label":"server side rendering permalink",className:"header-anchor after"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span class="hds-anchor-icon hds-icon hds-icon--link hds-icon--size-xs" aria-hidden="true" style="vertical-align: middle"></span>'}}))),"\n",r.createElement(a.Z,null,r.createElement(t.p,null,"The server-side rendering support of the Helsinki Design System makes the user's landing experience to pages smooth\nwithout flashes of unstyled content.")),"\n",r.createElement(t.h2,{id:"what-is-server-side-rendering",style:{position:"relative"}},"What is server-side rendering?",r.createElement(t.a,{href:"#what-is-server-side-rendering","aria-label":"what is server side rendering permalink",className:"header-anchor after"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span class="hds-anchor-icon hds-icon hds-icon--link hds-icon--size-xs" aria-hidden="true" style="vertical-align: middle"></span>'}}))),"\n",r.createElement(t.p,null,"Server-side rendering (SSR) is the process where the rendering of HTML pages is done on the server-side. The fully rendered HTML\ndocument is then sent to the browser. The rendering of the HTML can happen at build time (Static site generation\nor pre-rendering), or during an HTTP request. The alternative to SSR is client-side rendering (CSR), where most of the HTML\ncontent is composed and rendered in the browser using JavaScript."),"\n",r.createElement(t.h2,{id:"how-does-hds-support-server-side-rendering",style:{position:"relative"}},"How does HDS support server-side rendering?",r.createElement(t.a,{href:"#how-does-hds-support-server-side-rendering","aria-label":"how does hds support server side rendering permalink",className:"header-anchor after"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span class="hds-anchor-icon hds-icon hds-icon--link hds-icon--size-xs" aria-hidden="true" style="vertical-align: middle"></span>'}}))),"\n",r.createElement(t.p,null,"For HDS components to work with server-side rendering, you need to inject the critical CSS styles of the HDS components\nthat are being used into the initially rendered HTML on the server's side. For hds-core, you must include the styles from\nthe provided CSS files yourself. For hds-react HDS provides multiple options, which we will cover next."),"\n",r.createElement(i.Z,{label:"Critical CSS",className:"siteNotification"},r.createElement(t.p,null,"Critical CSS is applied to above-the-fold elements. It provides the styles for the immediately visible content in the\nbrowser viewport when the user opens your website. Critical CSS does not usually have the styles of the elements that\nare in the scrollable content outside of the browser viewport. There is one exception though, and that is if you have\nanchor links on the page. When user opens website from an URL that includes an anchor link, the browser automatically\nscrolls the page so that the link will be visible.")),"\n",r.createElement(t.h3,{id:"option-1-getcriticalhdsrules-tool-to-get-critical-styles-recommended",style:{position:"relative"}},"Option 1: getCriticalHdsRules tool to get critical styles (recommended)",r.createElement(t.a,{href:"#option-1-getcriticalhdsrules-tool-to-get-critical-styles-recommended","aria-label":"option 1 getcriticalhdsrules tool to get critical styles recommended permalink",className:"header-anchor after"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span class="hds-anchor-icon hds-icon hds-icon--link hds-icon--size-xs" aria-hidden="true" style="vertical-align: middle"></span>'}}))),"\n",r.createElement(t.p,null,"HDS React components use CSS-in-JS in a way where the styles are by default injected into the head tag in the browser.\nIf you use server-side rendering and do not include the critical styles on the server, this leads to flashes of unstyled\ncontent when the user lands on the page."),"\n",r.createElement(t.p,null,"To include critical styles on the server, HDS exposes a tool for extracting the used critical styles of HDS components.\nThis should come in handy in multiple ways:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"Automatically extracts styles based on used HTML."),"\n",r.createElement(t.li,null,"If you add more HDS components later, you do not need to remember to add their styles separately."),"\n",r.createElement(t.li,null,"If you happen to remove HDS components, you do not need to remember to remove their respective styles."),"\n"),"\n",r.createElement(t.p,null,"Let's go through a simple example of the usage of the tool:"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},'import { getCriticalHdsRules, hdsStyles } from "hds-react";\n\nconst criticalHdsRules = await getCriticalHdsRules(bodyHTML, hdsStyles);\n\nconst finalHTML =\n<html>\n  <head>\n    ...\n    <style data-used-styles dangerouslySetInnerHTML={{ __html: criticalHdsRules }} />\n  </head>\n  <body>\n    ...\n  </body>\n<html>\n')),"\n",r.createElement(t.p,null,"First, we import the tool that is named ",r.createElement(t.code,null,"getCriticalHdsRules"),". To be able to call it, we need two things:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"The initially to-be-rendered HTML body code as a string."),"\n",r.createElement(t.li,null,"hdsStyles - a variable holding all the styles of the HDS react components as a string."),"\n"),"\n",r.createElement(t.p,null,"Calling it returns a string containing the critical CSS styles. The rest is easy, we set those styles into\na style tag, that we will then inject into the finally rendered HTML document. It can be wise to cache the result of\n",r.createElement(t.code,null,"getCriticalHdsRules")," based on the function parameters in order to improve performance."),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Note: There is also a new ",r.createElement(t.code,null,"getCriticalHdsRulesSync")," function that is a syncronous version of ",r.createElement(t.code,null,"getCriticalHdsRules"),".")),"\n",r.createElement(t.p,null,"See below for more complete examples:"),"\n",r.createElement(l.A,{heading:"Next.js (pages router)",headingLevel:"4",language:"en",size:"s",theme:{"--padding-vertical":"var(--spacing-s)"}},r.createElement(t.p,null,"In the Next.js framework, create a file called _document.js in folder pages, and add this code to it:"),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"// pages/_document.js - tested with next.js version: 10.0.5 and 13.3.0\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\nimport { getCriticalHdsRules, hdsStyles } from 'hds-react';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx) {\n    const initialProps = await Document.getInitialProps(ctx);\n    const hdsCriticalRules = await getCriticalHdsRules(initialProps.html, hdsStyles);\n\n    return { ...initialProps, hdsCriticalRules };\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head>\n          <style data-used-styles dangerouslySetInnerHTML={{ __html: this.props.hdsCriticalRules }} />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n\nexport default MyDocument;\n")),r.createElement(t.p,null,"The styles can also be set in the ",r.createElement(t.code,null,"getInitialProps")),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},'  //  tested with next.js version: 13.3.0\n  static async getInitialProps(ctx: any) {\n    try {\n      const initialProps = await Document.getInitialProps(ctx);\n      const hdsCriticalRules = await getCriticalHdsRules(initialProps.html, hdsStyles);\n      const otherCSS = `div {\n        background:#ff0;\n      }`;\n      return {\n        ...initialProps,\n        styles: (\n          <>\n            <style id="hds-styles" dangerouslySetInnerHTML={{ __html: hdsCriticalRules }} />\n            <style>{otherCSS}</style>\n            {initialProps.styles}\n          </>\n        ),\n      };\n    } finally {\n    }\n  }\n'))),"\n",r.createElement(l.A,{heading:"Next.js (app router)",headingLevel:"4",language:"en",size:"s",theme:{"--padding-vertical":"var(--spacing-s)"}},r.createElement(t.p,null,"The newer version of Next.js has an app router. The router does not expose outputted HTML contents anymore, so the HTML needs to be rendered separately."),r.createElement(t.p,null,"Create a new component ",r.createElement(t.code,null,"HdsStylePicker.tsx")," in ",r.createElement(t.code,null,"src/components"),"."),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},'// tested with next.js version: 14.2.5\n\nimport ReactDOMServer from "react-dom/server";\nimport { useServerInsertedHTML } from "next/navigation";\nimport { useRef } from "react";\n// hds-react does not have export named "hdsStyles" in index.d.ts.\n// The object exists in the bundle, typescript just does not recognise it.\n//@ts-ignore\nimport { hdsStyles } from "hds-react";\nimport { getCriticalHdsRulesSync } from "@/utils/ssr";\n\nexport default function HdsStylePicker({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  const creationData = useRef<{ isSet: boolean; result: undefined | string }>({ isSet: false, result: undefined });\n\n  if (creationData.current.result === undefined) {\n    const res = ReactDOMServer.renderToString(<>{children}</>);\n    // using newer getCriticalHdsRulesSync and not older getCriticalHdsRules\n    const hdsCriticalRules = getCriticalHdsRulesSync(res, hdsStyles);\n    creationData.current = { ...creationData.current, result: hdsCriticalRules };\n  }\n\n  useServerInsertedHTML(() => {\n    // this function is called twice without "isSet" check.\n    // https://github.com/vercel/next.js/discussions/49354\n    if (!creationData.current.isSet) {\n      creationData.current = { ...creationData.current, isSet: true };\n      if (creationData.current.result) {\n        const contents = <style data-used-styles>{creationData.current.result}</style>;\n        return <>{contents}</>;\n      }\n      return undefined;\n    }\n  });\n  return <>{children}</>;\n}\n\n')),r.createElement(t.p,null,"This component cannot be used in the ",r.createElement(t.code,null,"layout.tsx"),", so every page must be wrapped with it. Note that ",r.createElement(t.code,null,'"use client";')," must be added as the first line."),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"'use client';\nimport HdsStylePicker from '@/components/HdsStylePicker';\n\nexport default function Home() {\n  return (\n    <HdsStylePicker>\n      <main>\n        {\n          // page contents\n        }\n      </main>\n    </HdsStylePicker>\n  );\n}\n"))),"\n",r.createElement(l.A,{heading:"Gatsby",headingLevel:"4",language:"en",size:"s",theme:{"--padding-vertical":"var(--spacing-s)"}},r.createElement(t.p,null,"In the Gatsby framework, create a file called gatsby-ssr.js at the root of the project, and add this code to it:"),r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"// gatsby-ssr.js - tested with gatsby version 4.17.0\nimport React from 'react';\nimport { getCriticalHdsRules, hdsStyles } from 'hds-react';\nimport { renderToString } from 'react-dom/server';\n\nexport const replaceRenderer = async ({ bodyComponent, setHeadComponents }) => {\n  const bodyHTML = renderToString(bodyComponent);\n\n  if (hdsStyles && hdsStyles.length > 0 && bodyHTML && bodyHTML.length > 0) {\n    const cssRules = await getCriticalHdsRules(bodyHTML, hdsStyles);\n    const HeadComponents = [<style data-used-styles dangerouslySetInnerHTML={{ __html: cssRules }} />];\n\n    return setHeadComponents(HeadComponents);\n  }\n\n  return;\n};\n"))),"\n",r.createElement(t.h3,{id:"option-2-use-indexcss-or-hdsstyles-not-recommended",style:{position:"relative"}},"Option 2: Use index.css or hdsStyles (not recommended)",r.createElement(t.a,{href:"#option-2-use-indexcss-or-hdsstyles-not-recommended","aria-label":"option 2 use indexcss or hdsstyles not recommended permalink",className:"header-anchor after"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span class="hds-anchor-icon hds-icon hds-icon--link hds-icon--size-xs" aria-hidden="true" style="vertical-align: middle"></span>'}}))),"\n",r.createElement(t.p,null,"HDS react provides all the styles of HDS components in a file called ",r.createElement(t.code,null,"index.css"),", located at the root of the library.\nYou can import that file and collect the critical CSS styles from there. Another alternative is to use exported variable\ncalled ",r.createElement(t.code,null,"hdsStyles"),":"),"\n",r.createElement(t.pre,null,r.createElement(t.code,{className:"language-js"},"import { hdsStyles } from 'hds-react';\n")),"\n",r.createElement(t.p,null,"This variable holds all the styles of HDS React components compiled into a single string. It might be tempting to include\nall the styles in ",r.createElement(t.code,null,"hdsStyles")," or ",r.createElement(t.code,null,"index.css")," to your HTML, and call it a day. This is not optimal because the size of the\nHDS styles is large and probably growing as new components are added to it. Adding all the styles might have an impact on the\nperformance of the app. Instead, you should collect only the necessary styles for the initial render. We recommend using\nthe tool described in option 1. But if you are unable to use that, extracting the critical CSS styles from either\n",r.createElement(t.code,null,"hdsStyles")," or ",r.createElement(t.code,null,"index.css")," might work out for you."),"\n",r.createElement(t.h3,{id:"customising-hds-components-and-server-side-rendering",style:{position:"relative"}},"Customising HDS components and server-side rendering",r.createElement(t.a,{href:"#customising-hds-components-and-server-side-rendering","aria-label":"customising hds components and server side rendering permalink",className:"header-anchor after"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span class="hds-anchor-icon hds-icon hds-icon--link hds-icon--size-xs" aria-hidden="true" style="vertical-align: middle"></span>'}}))),"\n",r.createElement(t.p,null,"If you customise hds-react components with the ",r.createElement("code",null,"theme")," prop, the style changes will not be visible on the\nfirst render. The preferred way to customise hds-react components with server-side rendering is using the ",r.createElement("code",null,"className"),"\nprop. However, notice that sometimes CSS selector specificity of 0-1-0 may not be enough to overwrite default CSS variables.\nThis depends on the CSS declaration order on the page or component's default styles selector specificity.\nYou may have to use a more specific CSS selector for the custom styles class, for example, ",r.createElement(t.code,null,"#myComponent.custom-class"),", ",r.createElement(t.code,null,".custom-class.custom-class"),", etc."))}t.default=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,s.ah)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)}},89482:function(e,t,n){var s=n(67294),r=n(42972);t.Z=e=>{let{color:t="var(--color-black-90)",size:n="var(--fontsize-body-xl)",style:l={},children:a}=e;return s.createElement("p",{style:{fontSize:n,color:t,maxWidth:600,...l}},(0,r.g)(a))}},77884:function(e,t,n){var s=n(67294),r=n(76358),l=n(42972);t.Z=e=>{let{children:t,...n}=e;return s.createElement(r.N,n,(0,l.g)(t))}}}]);