///
/* stylelint-disable scss/function-no-unknown */
///

@use "sass:string";
@use "sass:meta";
@use "sass:map";
@use "sass:list";
@use "sass:selector";
@use "./bem-util" as *;

/// GLOBALS

$globalRules: ();
$contentOnlyMarker: '@contentOnly';
$blockBaseStyles: '@blockBaseStyles';
$hasExplicitTrue: '@hasExplicitTrue';
$isExplicitlyDisallowed: '@isExplicitlyDisallowed';

/// HELPERS
/// Removes last item from list
@function pop-list($target) {
  $len: list.length($target);
  $copy: [];

  @if $len > 1 {
    @for $i from 1 through $len - 1 {
      $copy: list.append($copy, list.nth($target, $i));
    }
  }

  @return $copy;
}

// Returns the key of the first item in map that has a truthy value
@function get-map-key-with-value($target) {
  @if not $target {
    @return null;
  } @else {
    @each $name, $value in $target {
      @if $value {
        @return $name;
      }
    }
  }

  @return null;
}

@function is-value-boolean($value) {
  @return meta.type-of($value) == 'bool';
}

@function is-value-false($value) {
  @return is-value-boolean($value) and $value == false;
}

/// PROCESSING FUNCTIONS

@function start-processing($block: null, $modifier: null, $element: null, $content: null, $extra: null, $custom: null) {
  $queueParent: add-to-queue(
    $modifier: $modifier,
    $element: $element,
    $block: $block,
    $content: $content,
    $extra: $extra,
  );
  $level: map.get($globalRules, 'currentNestLevel');
  $selector: null;

  @if $content {
    $parentType: get-map-key-with-value($queueParent);

    ///  debug 'parentType: #{$parentType}, level: #{$level}, is-a: #{is-block-content-allowed()}';

    @if $parentType == 'block' and $level == 1 and is-block-content-allowed() == false {
      /// debug 'SHOULD NOT RENDER!';

      $selector: null;
    } @else {
      $selector: get-output-selector(
        $content: $content,
      );
    }
  } @else if $extra {
    $isExtraAllowed: is-extra-allowed($extra);

    @if $isExtraAllowed {
      $void: add-nest-level(
        $custom: $custom,
      );
      $selector: $custom;
    } @else {
      $selector: $contentOnlyMarker;
    }
  } @else {
    $selector: get-output-selector(
      $modifier: $modifier,
      $element: $element,
      $block: $block,
    );
  }

  /// debug 'selector1 #{$selector}';

  $contentOnly: should-render-only-content($selector);
  $shouldRender: if($selector, true, false);

  /// debug '$selector: #{$modifier} #{$selector}';

  $result: (
    'contentOnly': $contentOnly,
    'shouldRender': $shouldRender,
    'level': $level,
    'parent': $queueParent,
    'selector': $selector,
  );

  @return $result;
}

@function stop-processing($current) {
  @if should-pop-nesting($current) {
    $void: pop-nest-level();
  }

  $void: pop-queue();

  @return null;
}

/// PROCESS RETURN DATA CHECKS

@function is-content-only($current) {
  @return map.get($current, 'contentOnly');
}

@function should-render($current) {
  @return map.get($current, 'shouldRender');
}

@function should-pop-nesting($current) {
  @return should-render($current);
}

/// SELECTOR CREATION

@function get-output-selector($block: null, $modifier: null, $element: null, $content: null) {
  $result: get-rule-value(
    $modifier: $modifier,
    $element: $element,
    $block: $block,
    $content: $content,
  );
  $type: meta.type-of($result);
  $rootSelector: map.get($globalRules, 'rootSelector');
  $isFirstLevel: map.get($globalRules, 'currentNestLevel') == 0;

  ///  debug 'res #{$modifier}, #{$element}, #{$result}, #{$type}';

  @if not $type {
    @return null;
  }

  /// debug "currentNestLevel: #{map.get($globalRules, 'currentNestLevel')}";
  /// debug 'isFirstLevel:#{$isFirstLevel}, $rootSelector:#{$rootSelector}';

  @if $rootSelector and $isFirstLevel {
    $void: add-nest-level(
      $modifier: $modifier,
      $element: $element,
    );

    @return $contentOnlyMarker;
  }

  @if $type == 'bool' {
    // the @if above handles "false"
    $void: add-nest-level(
      $modifier: $modifier,
      $element: $element,
    );

    @return create-selector($rootSelector: $rootSelector);
  }

  @if $type == 'string' {
    $void: add-nest-level(
      $modifier: $modifier,
      $element: $element,
    );

    /// debug 'xxxx: #{$modifier}, #{$result}, ###{$rootSelector}';
    @return create-selector($override: $result, $rootSelector: $rootSelector);
  }

  // return values
  // null: do not render
  // $contentOnlyMarker: render only content
  // string: render with created selector
  @return null;
}

@function should-render-only-content($value) {
  @return $value == $contentOnlyMarker;
}

@function is-block-content-allowed() {
  $elements: map.get($globalRules, 'elements');

  @return map.get($elements, $blockBaseStyles) != false;
}

/// $rootSelector is for custom parent selectors
/// $override is for custom selectors from named parameters.
/// bem rules
/// https://en.bem.info/methodology/key-concepts/#bem-tree
/// https://en.bem.info/methodology/css/#selectors
@function create-selector($override: null, $rootSelector: null) {
  $block: map.get($globalRules, 'block');
  $nesting: map.get($globalRules, 'currentNesting');
  $blockSelector: '.#{$blockPrefix}#{$block}';
  $selector: if($rootSelector, $rootSelector, $blockSelector);
  $listLength: if($nesting, list.length($nesting), 0);
  $parent: null;

  // instead of calculating string length again and again, just define number big enough to force string concatenation
  // this limits selector lengths to be less than 10000 chars.
  /// "string.insert($target, $insert, $index)" docs: "If $index is higher than the length of $string, $insert is added to the end."
  $indexOutOfBounds: 10000;

  /// debug 'c-r #{$selector} listLength #{$listLength}';

  @if $listLength > 0 {
    $index: 0;

    @each $nestItem in $nesting {
      $newSelector: map-to-selector($nestItem);
      $entitySeparator: get-entity-separator(
        $parent,
        $nestItem,
        if($index == 0, if($rootSelector, '', $blockSelector), $rootSelector or $blockSelector)
      );

      /// debug 'c-r newSelector #{$newSelector}';
      /// debug meta.inspect($nestItem);

      // override only the current one
      @if $override and $index == $listLength - 1 {
        $newSelector: $override;
      }

      @if $newSelector {
        $selector: string.insert($selector, '#{$entitySeparator}#{$newSelector}', $indexOutOfBounds);
      }

      $index: $index + 1;
      $parent: $nestItem;
    }
  }

  /// debug 'c-r res #{$selector}';
  @return $selector;
}

/// modifier + element should result in .block--modifier .block__element, NOT .block--modifier__element
/// element + modifier should result in .block__element--modifier, NOT .block__element .block--modifier
/// element + element should not exist
@function get-entity-separator($parent: null, $current: null, $blockSelector: null) {
  @if $parent {
    $parentType: get-map-key-with-value($parent);
    $currentType: get-map-key-with-value($current);

    @if $parentType == 'modifier' and $currentType == 'element' {
      @return ' #{$blockSelector}';
    }

    @if $parentType == 'element' and $currentType == 'element' {
      @return ' #{$blockSelector}';
    }
  }

  @return '';
}

@function args-to-selector($argList...) {
  @return map-to-selector(meta.keywords($args: $argList));
}

@function map-to-selector($paramMap) {
  /// debug meta.inspect($paramMap);

  $block: map.get($globalRules, 'block');
  $prefix: null;
  $foundValue: null;

  @each $type, $value in $paramMap {
    @if $value {
      $foundValue: $value;

      @if $type == 'block' {
        $foundValue: $block;
        $prefix: '.#{$blockPrefix}';
      }

      @if $type == 'modifier' {
        $prefix: '#{$modifierDelimeter}';
      }

      @if $type == 'element' {
        $prefix: '#{$elementDelimeter}';
      }

      @if $type == 'class' {
        $prefix: '.';
      }

      @if $type == 'id' {
        $prefix: '#';
      }

      @if $type == 'dashed' {
        $prefix: '-';
      }

      @if $type == 'custom' {
        $prefix: '';
      }
    }
  }

  @if $prefix != null and $foundValue {
    @return '#{$prefix}#{$foundValue}';
  }

  @return '';
}

/// QUEUEING MANAGEMENT

@function add-to-queue($block: null, $modifier: null, $element: null, $content: null, $extra: null) {
  $current: map.get($globalRules, 'queue');
  $parent: get-current-working-item();
  $current: list.append(
    $current,
    (
      'block': $block,
      'modifier': $modifier,
      'element': $element,
      'content': $content,
      'extra': $extra,
    )
  );
  $globalRules: map.set($globalRules, 'queue', $current) !global;

  @return $parent;
}

@function get-current-working-item() {
  $queue: map.get($globalRules, 'queue');
  $len: if($queue, list.length($queue), 0);

  /// debug 'Q len: #{$len}';
  @return if($len > 0, list.nth($queue, -1), null);
}

@function get-current-working-item-type() {
  $current: get-current-working-item();

  /// debug 'current: #{meta.inspect($current)}';
  @return get-map-key-with-value($current);
}

@function pop-queue() {
  $newPosList: pop-list(map.get($globalRules, 'queue'));
  $globalRules: map.set($globalRules, 'queue', $newPosList) !global;

  /// debug 'pop Q len: #{list.length($newPosList)}';
  @return $newPosList;
}

@function add-nest-level($modifier: null, $element: null, $custom: null) {
  $current: map.get($globalRules, 'currentNesting');
  $current: list.append(
    $current,
    (
      'modifier': $modifier,
      'element': $element,
      'custom': $custom,
    )
  );
  $globalRules: map.set($globalRules, 'currentNesting', $current) !global;
  $globalRules: map.set($globalRules, 'currentNestLevel', list.length($current)) !global;

  /// debug "currentNestLevel: #{map.get($globalRules, 'currentNestLevel')}";
  @return $current;
}

@function pop-nest-level() {
  $current: map.get($globalRules, 'currentNesting');
  $len: list.length($current);
  $copy: [];

  @if $len > 1 {
    @for $i from 1 through $len - 1 {
      $copy: list.append($copy, list.nth($current, $i));
    }
  }

  $globalRules: map.set($globalRules, 'currentNesting', $copy) !global;
  $globalRules: map.set($globalRules, 'currentNestLevel', list.length($copy)) !global;

  /// debug 'nest end: #{get-selector()}';
  @return $current;
}

@function get-current-modifier() {
  $nesting: map.get($globalRules, 'currentNesting');
  $modifier: null;

  /// debug '----';
  /// debug meta.inspect($nesting);
  /// debug list.length($nesting);
  /// debug '----';

  @if $nesting and list.length($nesting) > 0 {
    @each $level in $nesting {
      $newModifier: map.get($level, 'modifier');

      @if $newModifier {
        $modifier: $newModifier;
      }
    }
  }

  @return $modifier;
}

/// CREATE A MAP
/// value can be boolean, string or a map
@function value-to-map($value, $prefix: null) {
  $returnValue: ();
  $valueType: meta.type-of($value);
  $allAccepted: true;
  $explicitlySetTrue: false;
  $isValueExplicitlyDisallowed: false;

  /// debug 'valueType: #{$valueType}';

  @if $valueType == 'bool' {
    $allAccepted: $value;

    @if not $value {
      $isValueExplicitlyDisallowed: true;
    }
  } @else if $valueType == 'string' {
    $returnValue: map.set($returnValue, $value, true);
    $allAccepted: false;
    $explicitlySetTrue: true;
  } @else if $valueType == 'map' {
    $allAccepted: false;
    $explicitlySetTrue: true;

    @each $itemName, $itemValue in $value {
      $returnValue: map.set($returnValue, '#{$prefix}#{$itemName}', $itemValue);

      @if $explicitlySetTrue == false and $itemValue == true {
        $explicitlySetTrue: true;
      }
    }
  }

  $returnValue: map.set($returnValue, 'all', $allAccepted);

  @if $explicitlySetTrue {
    $returnValue: map.set($returnValue, $hasExplicitTrue, true);
  } @else {
    /// debug 'NO EXPLICITS';
  }

  @if $isValueExplicitlyDisallowed {
    $returnValue: map.set($returnValue, $isExplicitlyDisallowed, $isValueExplicitlyDisallowed);
  }

  /// debug 'rv #{$allAccepted}';
  @return $returnValue;
}

/// CREATE GLOBAL RULE OBJECT

@function args-to-rules($args) {
  $block: map.get($args, 'block');
  $elements: ();
  $modifiers: ();
  $extras: ();
  $hasRoot: false;
  $rootSelector: null;
  $all: map.get($args, 'all');
  $hasOthersThanAll: false;
  $currentNesting: [];
  $queue: [];
  $currentNestLevel: 0;
  $parent: &;
  $hasSpecificModifiers: false;
  $testContainer: map.get($args, 'testContainer');

  /// debug 'parent #{$parent}';

  @if $parent {
    $hasRoot: true;

    /// convert list to string
    $rootSelector: #{$parent};

    /// debug 'testContainer #{$testContainer}';
    /// debug 'rootSelector #{$rootSelector}';

    @if $testContainer and string.index($rootSelector, $testContainer) {
      $rootSelector: null;
    }
  }

  /// Parse elements
  /// If elements == true, all elements are included
  /// If elements == string, given, named element is included
  /// If elements == map, elements are used as it is.
  /// debug "el #{map.get($args, 'elements')}";
  /// debug 'EL';

  $elements: value-to-map(map.get($args, 'elements'));
  $extras: value-to-map(map.get($args, 'extras'));

  /// Parse modifiers
  /// If modifiers == true, all modifiers are included
  /// If modifiers == string, the given, named modifier is included
  /// If modifiers == map, modifiers and elements are picked
  /// elements are stored as modifier__element
  $argModifiers: map.get($args, 'modifiers');
  $modifiers: value-to-map($argModifiers);

  /// debug 'argModifiers #{$argModifiers}';

  @if meta.type-of($argModifiers) == 'map' {
    @each $modifierName, $modifierValue in $argModifiers {
      $modifiers: map.set($modifiers, $modifierName, value-to-map($modifierValue));
    }
  }

  @if map.get($modifiers, $hasExplicitTrue) {
    $elements: map.set($elements, $blockBaseStyles, false);

    /// Might be correct
    $elements: map.set($elements, 'all', false);

    /// Might be correct
    $elements: map.set($elements, $hasExplicitTrue, true);
  }

  $rules: (
    'block': $block,
    'elements': $elements,
    'modifiers': $modifiers,
    'extras': $extras,
    'hasRoot': $hasRoot,
    'rootSelector': $rootSelector,
    'all': if($hasOthersThanAll, false, $all),
    'currentNesting': $currentNesting,
    'queue': $queue,
    'currentNestLevel': $currentNestLevel,
  );

  ///  debug '########';
  ///  debug meta.inspect($modifiers);
  ///  debug meta.inspect($elements);
  ///  debug '########';

  $globalRules: $rules !global;

  @return $rules;
}

///
/// By default all are allowed
/// (modifiers: false), all modifiers and modifier's element are NOT allowed. NOT CONTENT CURRENTLY??
/// (modifiers: true), all modifiers are allowed (default)
/// (modifiers: (modName:true)), only that modifier and its elements are allowed
/// (modifiers: (modName:false)), all modifiers  except modName are allowed
/// (modifiers: (modName:(elemName:false)), only that modifier is allowed and all its elements except elemName
/// (modifiers: (modName:(elemName:true)), only that modifier and only that element is allowed
/// (elements: true), all elements are allowed
/// (elements: false), all elements are NOT allowed
/// (elements: (elemName:false), all elements except elemName are allowed
/// (elements: (elemName:true), only that element is allowed
/// (modifier:(elemName:false),elements:(elemName:true)), elemName is not allowed, modifier takes precedence
/// (modifier:(elemName:true),elements:(elemName:false)), elemName is allowed, modifier takes precedence
/// (modifier:(elemName:true),elements:false)), elemName is allowed, modifier takes precedence
///
@function is-value-allowed($map, $item) {
  $allItemsAllowed: map.get($map, 'all');

  @if not $item {
    @return $allItemsAllowed;
  }

  $hasExplicitlyAllowedItems: map.get($map, $hasExplicitTrue);
  $isValueExplicitlyDisallowed: map.get($map, $isExplicitlyDisallowed);
  $itemValue: map.get($map, $item);

  /// debug '---is-value-allowed---';
  /// debug 'item #{$item}';
  /// debug 'hasExplicitlyAllowedItems #{$hasExplicitlyAllowedItems}';
  /// debug 'itemValue #{$itemValue}';
  /// debug 'allItemsAllowed #{$allItemsAllowed}';
  /// debug 'isValueExplicitlyDisallowed #{$isValueExplicitlyDisallowed}';
  /// debug '----';

  @if $isValueExplicitlyDisallowed {
    @return false;
  }

  @if $itemValue or $allItemsAllowed {
    @return true;
  }

  @if not $hasExplicitlyAllowedItems and not is-value-false($itemValue) {
    @return true;
  }

  @return false;
}

@function is-modifier-allowed($modifier) {
  @return is-value-allowed(map.get($globalRules, 'modifiers'), $modifier);
}

@function is-element-allowed($element) {
  @return is-value-allowed(map.get($globalRules, 'elements'), $element);
}

@function is-element-allowed-in-modifier($modifier, $element) {
  $modifiers: map.get($globalRules, 'modifiers');
  $modifierElements: map.get($modifiers, $modifier);

  /// modifier might not be stored, when all are allowed
  /// is-modifier-allowed must be called before this to make sure "true" is valid return value
  @if meta.type-of($modifierElements) != 'map' {
    @return true;
  }

  @return is-value-allowed($modifierElements, $element);
}

@function get-set-value-of($modifier, $element) {
  @if $modifier {
    $modifiers: map.get($globalRules, 'modifiers');
    $modifierValue: map.get($modifiers, $modifier);

    @if not $element {
      @return $modifierValue;
    }

    $elementValue: map.get($modifierValue, $element);

    @if $elementValue {
      @return $elementValue;
    }
  }

  @if $element {
    $elements: map.get($globalRules, 'elements');

    @return map.get($elements, $element);
  }

  @return null;
}

@function is-rule-allowed($block: null, $modifier: null, $element: null, $content: null) {
  @if $block or $content {
    @return true;
  }

  $currentModifier: if($modifier, $modifier, get-current-modifier());
  $modifierIsAllowed: is-modifier-allowed($currentModifier);

  @if not $element {
    ///  debug 'is mod allowed? Modifier: #{$currentModifier}: #{$modifierIsAllowed}';
    @return $modifierIsAllowed;
  } @else {
    $elementIsAllowed: is-element-allowed($element);

    ///  debug 'is element allowed? #{$element}=== #{$elementIsAllowed}';

    @if $currentModifier {
      @if not $modifierIsAllowed {
        ///  debug 'is element allowed? No. #{$currentModifier} is not allowed';
        @return false;
      }

      $elementIsAllowedInModifier: is-element-allowed-in-modifier($currentModifier, $element);

      @if not $elementIsAllowedInModifier {
        ///  debug 'is element allowed? No. #{$element} is not allowed in modifier #{$currentModifier}';
        @return false;
      }

      @if is-value-boolean($elementIsAllowedInModifier) and $elementIsAllowedInModifier {
        @return true;
      }
    }

    ///  debug 'element is allowed! #{$elementIsAllowed}, elem: #{$element}';
    @return $elementIsAllowed;
  }

  @return false;
}

@function get-rule-value($block: null, $modifier: null, $element: null, $content: null) {
  @if $block or $content {
    @return true;
  }

  $isAllowed: is-rule-allowed(
    $block: $block,
    $modifier: $modifier,
    $element: $element,
    $content: $content,
  );

  @if not $isAllowed {
    @return null;
  }

  // returns true, because target is allowed!
  @return get-set-value-of($modifier: $modifier, $element: $element) or true;
}

@function is-extra-allowed($extra: null) {
  $extras: map.get($globalRules, 'extras');
  $allExtrasAllowed: map.get($extras, 'all');
  $isAllowed: map.get($extras, $extra);

  /// debug '---allExtrasAllowed: #{$allExtrasAllowed}';
  /// debug '---isAllowed: #{$isAllowed}';
  @return $allExtrasAllowed == true or $isAllowed == true;
}

@mixin handle-output($processData) {
  $contentOnly: map.get($processData, 'contentOnly');
  $shouldRender: map.get($processData, 'shouldRender');
  $selector: map.get($processData, 'selector');

  /// debug 'selector #{$selector}';

  @if $contentOnly {
    @content;
  } @else if $shouldRender {
    @at-root {
      #{$selector} {
        @content;
      }
    }
  }
}

@mixin block() {
  $processData: start-processing(
    $block: true,
  );

  @include handle-output($processData) {
    @content;
  }

  $void: stop-processing($processData);
}

@mixin content($element) {
  $processData: start-processing(
    $content: $element,
  );

  @include handle-output($processData) {
    @content;
  }

  $void: stop-processing($processData);
}

@mixin modifier($modifier) {
  $processData: start-processing(
    $modifier: $modifier,
  );

  @include handle-output($processData) {
    @content;
  }

  $void: stop-processing($processData);
}

@mixin element($element) {
  $processData: start-processing(
    $element: $element,
  );

  @include handle-output($processData) {
    @content;
  }

  $void: stop-processing($processData);
}

@mixin extraRule(
  $block: null,
  $modifier: null,
  $element: null,
  $class: null,
  $dashed: null,
  $custom: null,
  $rule: null
) {
  $customSelector: args-to-selector(
    $block: $block,
    $modifier: $modifier,
    $element: $element,
    $class: $class,
    $dashed: $dashed,
    $custom: $custom,
  );
  $processData: start-processing(
    $extra: $rule,
    $custom: $customSelector,
  );

  @include handle-output($processData) {
    @content;
  }

  $void: stop-processing($processData);
}
