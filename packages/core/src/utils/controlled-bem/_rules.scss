/* stylelint-disable scss/function-no-unknown */
@use "sass:meta";
@use "sass:map";
@use './globals' as *;
@use './helpers' as helpers;

/// value can be boolean, string or a map
/// Parse modifiers
/// If value == true, all named entities are allowed
/// If value == false, all named entities are excluded
/// If value == string, only the given, named entity is allowed
/// If value == map, named entities are picked from the map:
///   if value = (name: string or name:true), only the given, named entity is allowed (multiple entities can be allowed)
///   if value = (name:false), the given, named entity is disallowed
///
/// Returns
///
/// value:true -> ("ALL_ALLOWED":true)
/// value:("childWithMap":("foo":"bar", "another":true) ->
///       ("childWithMap":true, "ALL_ALLOWED":false,"HAS_EXPLICIT_TRUE":true,  )
///
/// Nested maps are discarded and value is set to "true". @warn is triggered.
@function value-to-map($value) {
  $returnValue: ();
  $valueType: meta.type-of($value);
  $allAccepted: true;
  $explicitlySetTrue: false;

  /// debug 'valueType: #{$valueType}';

  @if $valueType == 'bool' {
    $allAccepted: $value;
  } @else if $valueType == 'string' {
    $returnValue: map.set($returnValue, $value, true);
    $allAccepted: false;
    $explicitlySetTrue: true;
  } @else if $valueType == 'map' {
    $allAccepted: false;

    @each $itemName, $itemValue in $value {
      @if helpers.is-value-map($itemValue) {
        @warn 'helpers.value-to-map: nested maps are not parsed. Stored value will be "true".';

        $returnValue: map.set($returnValue, $itemName, true);
        $explicitlySetTrue: true;
      } @else {
        @if helpers.can-value-be-truthy($itemValue) {
          $explicitlySetTrue: true;
        }

        $returnValue: map.set($returnValue, $itemName, $itemValue);
      }
    }
  }

  $returnValue: map.set($returnValue, $ALL_ALLOWED, $allAccepted);

  @if $explicitlySetTrue {
    $returnValue: map.set($returnValue, $HAS_EXPLICIT_TRUE, true);
  } @else {
    $returnValue: map.set($returnValue, $HAS_EXPLICIT_TRUE, false);
  }

  /// debug 'rv #{$allAccepted}';
  @return $returnValue;
}

@function rules-to-map($args) {
  $target: helpers.create-empty-map();
  $elements: value-to-map(map.get($args, 'elements'));
  $extras: value-to-map(map.get($args, 'extras'));
  $argModifiers: map.get($args, 'modifiers');
  $modifiers: value-to-map($argModifiers);

  @if helpers.is-value-map($argModifiers) {
    @each $modifierName, $modifierValue in $argModifiers {
      /// $modifiers: map.set($modifiers, $modifierName, value-to-map($modifierValue));
    }
  }

  @if map.get($modifiers, $HAS_EXPLICIT_TRUE) {
    $elements: map.set($elements, $ALLOW_BASE_CONTENT, false);
    $elements: map.set($elements, $ALL_ALLOWED, false);
  } @else if map.get($elements, $HAS_EXPLICIT_TRUE) {
    $elements: map.set($elements, $ALLOW_BASE_CONTENT, false);
  }

  $target: map.set($target, 'modifiers', $modifiers);
  $target: map.set($target, 'elements', $elements);
  $target: map.set($target, 'extras', $extras);

  @return $target;
}

// Rule picking and verification

@function get-parsed-map-value($namedMap, $name) {
  $value: map.get($namedMap, $name);
  $isAllowed: is-name-within-value($value, $name);

  @if not $isAllowed {
    @return $value;
  }

  $valueType: meta.type-of($value);

  @if $valueType == 'string' or $valueType == 'map' {
    @return $value;
  }

  @return $isAllowed;
}

@function get-rule-map-value($namedMap, $name) {
  $value: get-parsed-map-value($namedMap, $name);

  @if map.get($namedMap, $HAS_EXPLICIT_TRUE) == true and not $value {
    @return false;
  }

  @if helpers.is-value-null($value) and map.get($namedMap, $ALL_ALLOWED) == true {
    @return true;
  }

  @return $value;
}

@function is-name-within-value($value, $name) {
  $valueType: meta.type-of($value);

  @if meta.type-of($name) != 'string' {
    @return false;
  }

  @if $valueType == 'null' {
    @return false;
  } @else if $valueType == 'bool' {
    @return $value;
  } @else if $valueType == 'string' {
    @return $value == $name;
  } @else if $valueType == 'map' {
    @return is-name-within-value(map.get($value, $name), $name);
  }

  @return false;
}

/// purpose
/// rules have modifiers("element":true);
/// test if element is allowed in modifiers:
/// is-child-rule-allowed($rules, "modifiers", "element");

@function is-child-rule-allowed($namedMap, $name, $childName) {
  $value: get-rule-map-value($namedMap, $name);

  @if not $value {
    @return false;
  }

  @if helpers.is-value-map($value) {
    @return helpers.can-value-be-truthy(get-rule-map-value($value, $childName));
  }

  @return helpers.can-value-be-truthy($value);
}

@function is-rule-allowed($namedMap, $name) {
  $value: get-rule-map-value($namedMap, $name);

  @return helpers.can-value-be-truthy($value);
}

/// Entity, extra etc checks with rule map
@function is-modifier-allowed($ruleMap, $modifier) {
  @return is-rule-allowed(get-modifiers($ruleMap), $modifier);
}

@function is-element-allowed($ruleMap, $element) {
  @return is-rule-allowed(get-elements($ruleMap), $element);
}

@function is-modifier-element-allowed($ruleMap, $modifier, $element) {
  @if is-modifier-allowed($ruleMap, $modifier) {
    $modifiers: get-modifiers($ruleMap);

    @return helpers.can-value-be-truthy(get-rule-map-value($modifiers, $element));
  }

  @return false;
}

@function is-extra-allowed($ruleMap, $extra) {
  @return is-rule-allowed(get-extras($ruleMap), $extra);
}

@function is-base-content-allowed($ruleMap) {
  $elements: get-elements($ruleMap);

  @return helpers.can-value-be-falsy(map.get($elements, $ALLOW_BASE_CONTENT));
}

@function get-modifiers($ruleMap) {
  @return map.get($ruleMap, 'modifiers');
}

@function get-elements($ruleMap) {
  @return map.get($ruleMap, 'elements');
}

@function get-extras($ruleMap) {
  @return map.get($ruleMap, 'extras');
}
