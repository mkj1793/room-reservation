///
/* stylelint-disable scss/function-no-unknown */
///

@use "sass:string";
@use "sass:meta";
@use "sass:map";
@use "sass:list";
@use "sass:selector";
@use "./bem-util" as *;

@function valueToMap($value, $prefix: null) {
  $valueType: meta.type-of($value);
  $returnValue: ();
  @if $valueType == 'bool' {
    $returnValue: map.set($returnValue, 'all', $value);
  } @else if $valueType == 'string' {
    $returnValue: map.set($returnValue, $valueType, true);
  } @else if $valueType == 'map' {
    @if $prefix {
      @each $itemName, $itemValue in $value {
        $returnValue: map.set($returnValue, '#{$prefix}#{$itemName}', $itemValue);
      }
    } @else {
      $returnValue: $value;
    }
  }
  @return $returnValue;
}

/// all:true,
/// elements: base, content, caption, th, headerRow
/// modifiers: dense:(),dark,light,zebra,withVerticalLines,withVerticalHeader, textAlignRight
/// extras: container,
@function args-to-rules($args) {
  $block: '';
  $elements: ();
  $modifiers: ();
  $extras: ();
  $hasRoot: false;
  $all: map.get($args, 'all');
  $hasOthersThanAll: false;
  $parent: &;

  @if $parent {
    $hasRoot: true;
  }

  /// Parse elements
  /// If elements == true, all elements are included
  /// If elements == string, given, named element is included
  /// If elements == map, elements are used as it is.
  $elements: valueToMap(map.get($args, 'elements'));
  $extras: valueToMap(map.get($args, 'extras'));

  /// Parse modifiers
  /// If modifiers == true, all modifiers are included
  /// If modifiers == string, given, named modifier is included
  /// If modifiers == map, modifiers and elements are picked
  /// elements are stored as modifier__element
  $argModifiers: map.get($args, 'modifiers');
  $argModifiersType: meta.type-of($argModifiers);

  @if $argModifiersType == 'bool' and $argModifiers {
    $modifiers: map.set($modifiers, 'all', $argModifiers);
  } @else if $argModifiersType == 'string' {
    $modifiers: map.set($modifiers, $argModifiersType, true);
  } @else if $argModifiersType == 'map' {
    @each $modifierName, $modifierValue in $argModifiers {
      $modifiers: map.set($modifiers, $modifierName, if($modifierValue, true, false));
      @if $modifierValue {
        $elements: map.merge($elements, valueToMap($modifierValue, '#{$modifierName}#{$elementDelimeter}'));
      }
    }
  }

  $rules: (
    'block': $block,
    'elements': $elements,
    'modifiers': $modifiers,
    'hasRoot': $hasRoot,
    'all': if($hasOthersThanAll, false, $all),
  );

  @debug '####';
  @debug meta.inspect($elements);
  @debug meta.inspect($modifiers);
  @debug '####';
  @return $rules;
}

@function get-rule($rules, $modifier: null, $element: null) {
  $modifiers: map.get($rules, 'modifiers');
  $modifierAllowed: map.get($modifiers, if($modifier, $modifier, 'all'));
  $elements: map.get($rules, 'elements');
  $elementWithModifier: if($modifier, '#{$modifier}#{$elementDelimeter}#{$element}', $element);
  $all: map.get($rules, 'all') == true;

  @if $all {
    @return true;
  }

  @if not $element {
    @return $modifierAllowed;
  } @else {
    @return if($modifierAllowed, true, map.get($elements, $element));
  }

  @return null;
}

@mixin block($rules) {
  $value: get-rule($rules, null, 'base');
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include create($block: map.get($rules, 'block')) {
      @content;
    }
  }
}

@mixin blockModifier($rules, $modifierName) {
  $value: get-rule($rules, $modifierName);
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include create($block: map.get($rules, 'block'), $modifier: $modifierName) {
      @content;
    }
  }
}

@mixin blockModifierElement($rules, $modifierName, $elementName) {
  $value: get-rule($rules, $modifierName, $elementName);
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include create($block: map.get($rules, 'block'), $modifier: $modifierName, $element: $elementName) {
      @content;
    }
  }
}

@mixin modifier($rules, $modifierName) {
  $value: get-rule($rules, $modifierName);
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include modifier($modifierName) {
      @content;
    }
  }
}

@mixin dashed($rules, $className) {
  $value: get-rule($rules, $className);
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include dashed($className) {
      @content;
    }
  }
}

@mixin blockCompoundModifier($rules, $modifierName) {
  $value: get-rule($rules, $modifierName);
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include blockCompoundModifier(map.get($rules, 'block'), $modifierName) {
      @content;
    }
  }
}

@mixin element($rules, $element) {
  $value: get-rule($rules, $element);
  $hasRoot: map.get($rules, 'hasRoot');

  @if $hasRoot and $value {
    @content;
  } @else if $value {
    @include element($element) {
      @content;
    }
  }
}

@mixin content($rules, $modifier: null, $element: null) {
  $value: get-rule($rules, $modifier, $element);

  @if $value {
    @content;
  }
}

@mixin compoundModifiers($blockName, $modifier1Name, $modifier2Name) {
  $mod1Value: get-rule($rules, $modifier1Name);
  $mod2Value: get-rule($rules, $modifier2Name);

  @if $mod1Value and $mod2Value {
    @include blockCompoundModifier(map.get($rules, 'block'), $modifier1Name, $modifier2Name) {
      @content;
    }
  }
}

@mixin elementInCompoundModifiers($blockName, $modifier1Name, $modifier2Name, $elementName) {
  $mod1Value: get-rule($rules, $modifier1Name, $elementName);
  $mod2Value: get-rule($rules, $modifier2Name, $elementName);

  @if $mod1Value and $mod2Value {
    @include elementInCompoundModifiers(map.get($rules, 'block'), $modifier1Name, $modifier2Name) {
      @content;
    }
  }
}
